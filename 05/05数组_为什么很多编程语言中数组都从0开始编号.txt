线性表：数组、链表、队列、栈
非线性表：二叉树、堆，图
数组和链表的区别：数组支持随机访问，根据下标随机访问的时间复杂度为
O(1),查找的时间复杂度是O(logn) 
链表适合插入、删除，时间复杂度O(1)
ArrayList：可以将很多数组操作的细节封装起来，支持动态扩容(1.5*)
缺点：扩容比较耗时，尽量事前指定好数据大小

ArrayList<User> users = new ArrayList(10000);
for(int i=0;i<10000;++i){
	users.add(xxx);
}

“下标”最确切的定义应该是“偏移”，a[0]表示偏移为0
a[k]_address = base_address + k*type_size


课后问题：

Q:
1、前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。
我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，
可以在评论区回顾下你理解的标记清除垃圾回收算法。
2、前面我们讲到一维数组的内存寻址公式，
那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？

A:
JVM标记清除算法：

大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。

不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。

二维数组内存寻址：

对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为：

address = base_address + ( i * n + j) * type_size